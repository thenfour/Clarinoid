// see also ScaleFollower.hpp for the serialization format.

//#define _CRT_SECURE_NO_WARNINGS

#define CLARINOID_PLATFORM_X86
#define CLARINOID_MODULE_TEST // OK this is not a test, but because we pull in all headers, we use test foundation like test timer instead of real timer.

#include <clarinoid/x86/ArduinoEmu.hpp>
#include <clarinoid/basic/Basic.hpp>
#include <clarinoid/scale_follower/ScaleFollower.hpp>
#include <fstream>
#include <sys/stat.h>
#include <map>

using MapKey = ScaleFollowerDetail::MapKey;
using MapValue = ScaleFollowerDetail::MapValue;
using ScaleFollowerDetail::IndexToMapKey;

bool Contains(const std::vector<Note>& cont, Note n)
{
  for (auto& x : cont)
  {
    if (x == n) return true;
  }
  return false;
}

int CalcFitness(const Scale& currentScale, const std::vector<Note>& playingNotes, const Scale& candidateScale)
{
  int ret = 0;
  // big points if it contains ALL the notes playing
  auto candidateDiatonic = currentScale.GetDiatonicNotes();

  int playingMatches = 0;
  int currentMatches = 0;

  for (auto& playing : playingNotes) {
    if (Contains(candidateDiatonic, playing))
    {
      playingMatches++;
    }
  }

  // small points for containing notes of the current scale.
  auto currentDiatonic = currentScale.GetDiatonicNotes();
  for (auto& curr : currentDiatonic)
  {
    if (Contains(candidateDiatonic, curr)) {
      currentMatches++;
    }
  }

  return (playingMatches * 2) + (currentMatches * 1);
}

bool ltpairintscale(const std::pair<int, Scale>& lhs, const std::pair<int, Scale>& rhs)
{
  return lhs.first < rhs.first;
}

std::map<MapKey, MapValue> GenerateMap()
{
  // # of notes to actually use in mapping dest scale.
  //static const size_t SCALE_DISAMBIGUATION_MAPPING_NOTES = 4;
  // # of notes in the recent pool which results in the above mapping.
  // we are polyphonic so you may need to throw out up to MAX_MUSICAL_VOICES number of voices if they are found to be too short.
  //static const size_t SCALE_DISAMBIGUATION_NOTES_TO_ANALYZE = SCALE_DISAMBIGUATION_MAPPING_NOTES + MAX_MUSICAL_VOICES;

  //   [4 bits scale flavor]
  //   [12 bits of context notes, relative to scale root. each bit = note on or off]
  size_t mapSize = (1 << 16);
  std::map<MapKey, MapValue> ret;
  for (size_t i = 0; i < mapSize; ++i)
  {
    MapKey k = IndexToMapKey(i); // map key is the current scale flavor + playing notes
    Scale currentScale = Scale(0, k.mScaleFlavor); // make everything relative to (0) for simplicity
    MapValue v;
    SortedArray<std::pair<int, Scale>, 50, decltype(&ltpairintscale)> candidateScales(&ltpairintscale);

    std::vector<Note> playingNotes;
    for (int note = 0; note < 12; ++note) {
      if (k.mPlayingNotes[note]) {
        playingNotes.push_back((Note)note);
      }
    }

    // figure out which scale would be most suitable.
    // skip any scales which are not eligible for scale following
    for (int note = 0; note < 12; ++note)
    {
      for (int scaleFlavor = 0; scaleFlavor < ScaleFlavorCount; ++scaleFlavor)
      {
        auto f = gScaleFlavors[scaleFlavor];
        if (!f.IsAllowedInScaleFollower()) {
          continue;
        }
     
        Scale candidateScale = Scale(note, f.mID);
        // calculate a fitness based on current scale, actual playing notes, and dest scale.
        // we could construct a hypothetical scale which includes notes of the original, replaced by notes being played.
        int fitness = CalcFitness(currentScale, playingNotes, candidateScale);
        candidateScales.Insert(std::make_pair(fitness, candidateScale));
      }
    }

    CCASSERT(candidateScales.mSize);

    // here is the most suitable scale.
    auto chosenScale = candidateScales.mArray[0].second;
    v.mRelativeRoot = chosenScale.mRootNoteIndex; // because we start at C=0 scale, the new scale root is already relative.
    v.mScaleFlavor = chosenScale.mFlavorIndex;
    ret[k] = v;
  } // for each map entry

  return ret;
}



// Map context to a new scale.
// KEY:
//   [4 bits scale flavor]
//   [12 bits of context notes, relative to scale root. each bit = note on or off]
//
void Go(std::ostream& outp)
{
  auto map = GenerateMap();

  outp << std::endl << "// THIS FILE IS GENERATED by GenerateScaleFollowerLUT" << std::endl << std::endl;
  //outp << "#pragma once" << std::endl << std::endl;
  outp << "uint16_t gScaleToScaleMappings[" << map.size() << "] =" << std::endl;
  outp << "{" << std::endl;
  for (size_t i = 0; i < map.size(); ++i) {
    MapKey k = IndexToMapKey(i);
    auto& v = map[k];
    // convert scale to int16.
    outp << "  " << v.Serialize() << ",";
    if ((i % 12) == 11) // prettier to put many on 1 line
      outp << std::endl;
  }
  outp << "};" << std::endl << std::endl;
}


inline bool FileExists(const std::string& name) {
  struct stat buffer;
  return (stat(name.c_str(), &buffer) == 0);
}

int main()
{
  // determine path.
  std::string path = ".\\src\\clarinoid\\scale_follower\\ScaleFollowerLUT.hpp";
  bool found = false;

  for (int i = 0; i < 10; ++i) {
    if (FileExists(path)) {
      found = true;
      break;
    }
    path = std::string("..\\") + path;
  }
  if (!found) {
    cc::log("couldn't find the output file; outta here.");
    return 0;
  }

  cc::log("Output file: %s", path.c_str());

  {
    std::ofstream f;
    f.open(path);
    Go(f);
  }
  return 0;
}
