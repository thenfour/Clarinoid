
#define CLARINOID_PLATFORM_X86
#define CLARINOID_MODULE_TEST // OK this is not a test, but because we pull in all headers, we use test foundation like test timer instead of real timer.

#include <array>
#include <fstream>
#include <sys/stat.h>
#include <map>

#include <clarinoid/x86/ArduinoEmu.hpp>
#include "../BASSOONOID/src/bsBaseSystemSettings.hpp"

#include <clarinoid/basic/Basic.hpp>


static constexpr int XSize = 7; // log2.
static constexpr int YSize = 7; // log2


template<int xsize, int ysize>
std::vector<int16_t> GenerateLUT()
{
  clarinoid::ModCurve::ModulationCurveLUT<xsize, ysize, 15> lut;
  std::vector<int16_t> ret;
  ret.reserve(lut.LutSizeTotal);
  std::copy(lut.mpLut, lut.mpLut + lut.LutSizeTotal, std::back_inserter(ret));
  return ret;
}

void Go(std::ostream& outp)
{
  auto map = GenerateLUT<XSize, YSize>();

  outp << std::endl << "// THIS FILE IS GENERATED by GenerateModCurveLUT" << std::endl << std::endl;
  outp << "#pragma once" << std::endl;

  outp << "static const int16_t PROGMEM gModCurveLUTData[" << map.size() << "] =" << std::endl;
  outp << "{" << std::endl;
  size_t i = 0;
  for (auto& kv : map) {
    ++i;
    // convert scale to int8.
    outp << " " << kv << ",";
    if (!(i % 16)) // prettier to put many on 1 line
      outp << std::endl;
  }
  outp << "};" << std::endl;
  //outp << "static clarinoid::ModCurve::ModulationCurveLUT<" << XSize << ", " << YSize << ", 15> gModCurveLUT(const_cast<int16_t*>(&gModCurveLUTData[0]));"  << std::endl;

  outp << "#define CLARINOID_MODCURVE_LUT" << std::endl;
}

int main()
{
  // determine path.
  std::string path = ".\\src\\clarinoid\\basic\\ModCurveLUT.hpp";
  auto FileExists = [](const std::string& name) {
    struct stat buffer;
    return (stat(name.c_str(), &buffer) == 0);
  };

  bool found = false;

  for (int i = 0; i < 10; ++i) {
    if (FileExists(path)) {
      found = true;
      break;
    }
    path = std::string("..\\") + path;
  }
  if (!found) {
    clarinoid::log("couldn't find the output file; outta here.");
    return 0;
  }

  clarinoid::log("Output file: %s", path.c_str());

  {
    std::ofstream f;
    f.open(path);
    Go(f);
    f.flush();
    f.close();
  }
  return 0;
}
