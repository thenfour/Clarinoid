// - tri-square, very straightforward
// and here, i introduce the various "mod modes" for oscillators: hard sync, bitcrush, sample&hold.

// but regarding auto-phase, something like this feels VERY suitable for auto-phase,
// but hte best i have gotten so far is pretty OK except that it keeps like toggling octaves.

desc:tenfour-tri-square
slider1:2<.1,8,0.001>slave (%)
slider2:1000<20,20000,0.001>master (Hz)
slider3:0<-.5,.5,0.001>phase offset
slider4:.5<0,1,0.001>shape1
slider5:.5<0,1,0.001>shape2
//slider6:1<0,1,1>enable sync
//slider7:1<0,1,1>enable auto-phase
slider8:0<0,1,1{off,hard sync,xcrush,ycrush}>mod mode

slider10:1<0,1,1>bleps


@init

MODMODE_OFF = 0;
MODMODE_HARDSYNC = 1;
MODMODE_XCRUSH = 2;
MODMODE_YCRUSH = 3;

function Clamp(x, l, h)
(
  min(h, max(l, x))
);

function fract(a)
(
  a - floor(a);
);

function does_encounter(t1, t2, x)
(
  (t1 < t2) ? (
    t1 < x && x <= t2
  ):(
    x <= t2 || x > t1
  )
);

// AA correction polynomial to be added THIS sample.
// x is 0-1 samples after the discontinuity.
function blep_before(x)
(
  x*x;
);

// AA correction polynomial to be added NEXT sample.
// x is 0-1 samples after the discontinuity.
function blep_after(x)
(
  x = 1 - x;
  -x*x;
);

function blamp_before(x)
(
    (1.0 / 3.0) * x * x * x;
);

function blamp_after(x)
(
    x = x - 1;
    (-1.0 / 3.0) * x * x * x;
);

function lerp(a, b, i)
(
  (b - a) * i + a;
);


// https://www.desmos.com/calculator/xg0o8hflwv
// bring sL into 0-1 range
function QuantizeSafe(sR, levels)
(
  sR = Clamp(sR, -.99, .99);
  m = levels * .5; // double the poles, half the levels.
  sR= floor(sR*m+.5);
  sR /= m;
  sR
);

function QuantizeChaotic(sR, levels)
(
  sR = Clamp(sR, -.99, .99);
  sR = sR * .5 + .5;
  o = .5 / levels; // an offset which helps find the correct window before quantization.
  sR = floor((sR-o)*levels+.5);
  sR /= levels;
  sR += o;
  sR = sR*2-1;
  sR
);

// returns Y value at specified phase. instance / stateless.
function OSC_NAIVE_SAMPLE(t)
(
  //--------------------------------------------------------
  // edge    0   t1  t2        t3  1
  //         |    |  |          |  |
  //         -----,                , +1
  //               \              /
  //                \            /
  //                 `----------`    -1
  // width   |----|
  // slope        |--|          |--|

  // derivative
  // edge    0   t1  t2        t3  1
  //         |    |  |          |  |
  //                            ---- ((slope*2))
  //         -----   -----------     0
  //              ---                -((slope*2))
  
  (t < this.t1) ? (
    1
  ) : (t < this.t2) ? (
    1-2*(t - this.t1) / this.slope
  ) : (t < this.t3) ? (
    -1
  ) : (
    -1+2*(t - this.t3) / this.slope
  );
  
);

// returns Y value at specified phase. instance / stateless.
function OSC_NAIVE_SAMPLE_SLOPE(t)
(
  (t < this.t1) ? (
    0
  ) : (t < this.t2) ? (
    -1/this.slope
  ) : (t < this.t3) ? (
    0
  ) : (
    1/this.slope
  );
);

function OSC_SETPARAMS(freq, _phaseOffset, _slope, _width, _masterFreq)
(
  this.freq = freq;
  this.phaseOffset = fract(_phaseOffset);
  
  this.slope = lerp(.49,.05,_slope);
  this.width = _width;
  
  this.dt = freq / srate; // amount to advance phase each sample
  this.y0 = 0; // these are really just used as return values.
  this.y1 = 0;
  
  remainingSpace = 1-2*this.slope;
  this.width *= remainingSpace;
  
  this.t1 = this.width;
  this.t2 = this.width + this.slope;
  this.t3 = 1 - this.slope; 
  
  this.DCOffset = 0;
  this.scale = 1;
);

function OSC_ACCUMULATE_BLEP(newPhase, edge, blepScale, samples, samplesFromNewPositionUntilNextSample)
(
  does_encounter(this.phase, newPhase, edge) ? (
    samplesSinceEdge = fract(newPhase - edge) / this.dt;
    samplesFromEdgeToNextSample = fract(samplesSinceEdge + samplesFromNewPositionUntilNextSample);
    
    this.y1 += blepScale * blep_before(samplesFromEdgeToNextSample);
    this.y0 += blepScale * blep_after(samplesFromEdgeToNextSample);
  );
);

function OSC_ACCUMULATE_BLAMP(newPhase, edge, blampScale, samples, samplesFromNewPositionUntilNextSample)
(
  does_encounter(this.phase, newPhase, edge) ? (
    samplesSinceEdge = fract(newPhase - edge) / this.dt;
    samplesFromEdgeToNextSample = fract(samplesSinceEdge + samplesFromNewPositionUntilNextSample);
    
    this.y1 += blampScale * blamp_before(samplesFromEdgeToNextSample);
    this.y0 += blampScale * blamp_after(samplesFromEdgeToNextSample);
  );
);

// instance; advances phase.
// samples is 0<samples<1
// assume this.phase is currently 0<t<1
// this.phase may not be on a sample boundary.
function OSC_ADVANCE(samples, samplesTillNextSample) local(phaseToAdvance, newPhase)
(
  phaseToAdvance = samples * this.dt;
  newPhase = fract(this.phase + phaseToAdvance); // advance slave; doing it here helps us calculate discontinuity.

  this.y1 = 0;
  this.y0 = 0;
  
  scale = this.dt / (this.slope);
  this.OSC_ACCUMULATE_BLAMP(newPhase, 0/*edge*/, -scale, samples, samplesTillNextSample);
  this.OSC_ACCUMULATE_BLAMP(newPhase, this.t1/*edge*/, -scale, samples, samplesTillNextSample);
  this.OSC_ACCUMULATE_BLAMP(newPhase, this.t2/*edge*/, scale, samples, samplesTillNextSample);
  this.OSC_ACCUMULATE_BLAMP(newPhase, this.t3/*edge*/, scale, samples, samplesTillNextSample);
  
  this.phase = newPhase;
);

// process discontinuity due to restarting phase right now.
// so far this works generically for tri, saw, pulse. yee!
function OSC_RESTART(samplesBeforeNext) local(blepscale, sampleAfter)
(
  sampleBefore = this.OSC_NAIVE_SAMPLE(this.phase);
  
  newPhase = fract(this.phaseOffset);

  // fix bleps
  sampleAfter = this.OSC_NAIVE_SAMPLE(newPhase);
  blepscale = (sampleAfter - sampleBefore)*.5; // full sample scale is 2; *.5 to bring 0-1

  this.y1 = blepscale * blep_before(samplesBeforeNext); // blep the phase restart.
  this.y0 = blepscale * blep_after(samplesBeforeNext);
  
  // fix blamps.
  slopeBefore = this.OSC_NAIVE_SAMPLE_SLOPE(this.phase);
  slopeAfter = this.OSC_NAIVE_SAMPLE_SLOPE(newPhase);
  blampScale = this.dt * (slopeAfter - slopeBefore);
  this.y1 += slider20 * blampScale * blamp_before(samplesBeforeNext);
  this.y0 += slider20 * blampScale * blamp_after(samplesBeforeNext);
  this.phase = newPhase;
);

// process discontinuity due to restarting phase right now.
// so far this works generically for tri, saw, pulse. yee!
function OSC_HOLD(samplesBeforeNext)
(
  newHeldValue = this.OSC_NAIVE_SAMPLE(this.phase);
  blepscale = (newHeldValue - this.heldValue)*.5; // full sample scale is 2; *.5 to bring 0-1
  this.heldValue = newHeldValue;

  this.y1 = blepscale * blep_before(samplesBeforeNext); // blep the phase restart.
  this.y0 = blepscale * blep_after(samplesBeforeNext);
);


@slider
gPhaseOffset = slider3;
gBlepAmt = slider10;
(gModMode == MODMODE_HARDSYNC) ? (
  f0 = slider2;
  f1 = slider1 * slider2;
):(gModMode==MODMODE_XCRUSH)?(
  f0 = (slider1 + 1) * slider2 * 3; // +1 so the range is 1-*; *2 keeps the range similar to ycrush
  f1 = slider2;
):(
  f0 = slider1;
  f1 = slider2;
);

gShape = slider4;
gShape2 = slider5;
gModMode = slider8;

slave.OSC_SETPARAMS(f1, gPhaseOffset, gShape, gShape2, f0);

//aSyncFreqRem = fract(f0 / f1);

dt0 = f0 / srate;

@sample

y1 = y0; // THIS sample.
y0 = 0; // a value that gets added to the next sample. we first blep, then sample the sawtooth

// Push master phase forward by full sample.
t0 = fract(t0 + dt0);
((t0 >= dt0) || (gModMode == MODMODE_OFF) || (gModMode == MODMODE_YCRUSH)) ? (

  slave.OSC_ADVANCE(1, 0);
  y0 += slider10 * slave.y0;
  y1 += slider10 * slave.y1;
  
  gModMode == MODMODE_XCRUSH ? (
    // current sample will be used on next sample (this is the 1-sample delay)
    y0 += slave.heldValue;
  ):(
    // current sample will be used on next sample (this is the 1-sample delay)
    y0 += slave.OSC_NAIVE_SAMPLE(slave.phase);
  );
  out = (y1 + slave.DCOffset) * slave.scale; // y1 is old y0 plus new bleps

) :(gModMode == MODMODE_HARDSYNC) ? ( // samplecrush or hard sync goes here
  //                   sync
  //  prevsample         |    thissample
  //           |         <=x=>|
  //           |<==1-x==>     |

  x = t0 / dt0; // master sample remainder, in samples.
  
  slave.OSC_ADVANCE(1 - x, x);
  y0 += slider10 * slave.y0;
  y1 += slider10 * slave.y1;

  slave.OSC_RESTART(x);
  y0 += slider10 * slave.y0;
  y1 += slider10 * slave.y1;

  slave.OSC_ADVANCE(x, 0);
  y0 += slider10 * slave.y0;
  y1 += slider10 * slave.y1;
  
  // current sample will be used on next sample (this is the 1-sample delay)
  y0 += slave.OSC_NAIVE_SAMPLE(slave.phase);
  out = (y1 + slave.DCOffset) * slave.scale; // y1 is old y0 plus new bleps

) :(gModMode == MODMODE_XCRUSH) ? ( // samplecrush or hard sync goes here

  x = t0 / dt0; // master sample remainder, in samples.
  
  slave.OSC_ADVANCE(1 - x, x);
  y0 += slider10 * slave.y0;
  y1 += slider10 * slave.y1;

  slave.OSC_HOLD(x);
  y0 += slider10 * slave.y0;
  y1 += slider10 * slave.y1;

  slave.OSC_ADVANCE(x, 0);
  y0 += slider10 * slave.y0;
  y1 += slider10 * slave.y1;

  // current sample will be used on next sample (this is the 1-sample delay)
  y0 += slave.heldValue;
  out = (y1 + slave.DCOffset) * slave.scale; // y1 is old y0 plus new bleps

);

(gModMode == MODMODE_YCRUSH) ? (
  // bit crush
  //  out = QuantizeChaotic(out, slider1+1); <-- not necessary for lfo; feels less predictable and while it serves bitcrush effect well, doesn't matter at all for lfo purposes.
  out = QuantizeSafe(out, slider1+1);
);

spl0 = spl1 = out;



